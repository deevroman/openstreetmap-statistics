    <!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" >
  <meta name="viewport" content="width=800">
  <meta name="description" content="Monthly updated interactive statistics of OpenStreetMap.">
  <title>OpenStreetMap Statistics</title>
  <script src="assets/plotly-custom.min.js"></script>
  <link rel="stylesheet" type="text/css" href="index.css">
  <script defer data-domain="piebro.github.io/openstreetmap-statistics" src="https://plausible.io/js/script.js"></script>
  
</head>

<script>

topics = {
    "General": {
        "How many people are contributing each month?": {
            "url_hash": "63f6",
            "content_functions": [
                add_single_line_plot("general_contributor_count_monthly", "contributors per month", "contributors"),
                add_single_line_plot("general_new_contributor_count_monthly", "new contributors per month", "contributors"),
                add_multi_line_plot("general_contributor_count_more_the_k_edits_monthly", "contributors with more than k edits total", "contributors")
            ]
        },
        "Why is there rapid growth in monthly contributors in 2016?":{
            "url_hash": "21d9",
            "content_functions": [
                add_text("That's because a lot of new people were contributing using the maps.me app. Looking at the plot of" + 
                         " monthly contributors not using maps.me shows that there is linear growth. It is also worth noting" +
                         " that vast majority of maps.me mappers made only few edits. And due to definciencies in provided" +
                         " editor quality of their edits was really low."),
                add_single_line_plot("general_no_maps_me_contributor_count_monthly", "contributors per month without maps.me contributors", "contributors")
            ]
        },
        "How many edits are from users from which year?": {
            "url_hash": "d993",
            "content_functions": [
                add_multi_line_plot("general_contributor_count_attrition_rate_yearly", "edit count of users depending in which year their first edit was", "edits", percent=false, on_top_of_each_other=true, bar_chart=true),
                add_multi_line_plot("general_contributor_count_attrition_rate_yearly_percent", "percent of edits of users depending in which year their first edit was", "%", percent=true, on_top_of_each_other=true, bar_chart=true)
                
            ]
        },
        "How many edits are added each month/year?": {
            "url_hash": "fe79",
            "content_functions":[
                add_single_line_plot("general_edit_count_monthly", "edits per month", "edits"),
                add_single_line_plot("general_edit_count_yearly", "edits per year", "edits")
            ]
        },
        "What's the total amount of contributors, edits and changesets over time?": {
            "url_hash": "7026",
            "content_functions":[
                add_single_line_plot("general_new_contributor_count_monthly_accumulated", "total contributor count", "contributors"),
                add_single_line_plot("general_edit_count_monthly_accumulated", "total edit count", "edits"),
                add_single_line_plot("general_changeset_count_monthly_accumulated", "total changeset count", "changesets"),
            ]
        },
        "Where are edits made?": {
            "url_hash": "727b",
            "content_functions": [
                add_map_plot("general_edit_count_map_total", "total edits")
            ]
        },
        "Where are edits made each year?": {
            "url_hash": "bd16",
            "content_functions": [
                add_multiple_map_plots("general_edit_count_maps_yearly")
            ]
        },
        "What's the median edit count per contributor each month?": {
            "url_hash": "a3ed",
            "content_functions": [
                add_single_line_plot("general_edit_count_per_contributor_median_monthly", "median number of edits per contributor per month", "median number of edits per contributor"),
                add_single_line_plot("general_edit_count_per_contributor_median_monthly_since_2010", "median number of edits per contributor per month since 2010", "median number of edits per contributor")
            ]
        }
    },
    "Editing Software": {
        "How many people are contributing per editing software each month?": {
            "url_hash": "c229",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_contributor_count_monthly", "monthly contributor count per editing software", "contributors"),
                add_multi_line_plot("created_by_top_10_new_contributor_count_monthly", "monthly new contributor count per editing software", "contributors"),
                add_table("created_by_top_100_contributor_count_yearly", "yearly contributor count per editing software", "Editing Software", "created_by_top_100_contributor_count_total", "created_by_name_to_link"),
            ]
        },
        "How popular is each editing software per month?": {
            "url_hash": "158c",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_contributor_count_monthly_percent", "percent of contributors that use each editing software per month", "%", percent=true),
            ]
        },
        "Which editing software is used for the first edit?": {
            "url_hash": "7662",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_contributor_count_first_changeset_monthly", "monthly first editing software contributor count", "contributors"),
            ]
        },
        "How many edits are added per editing software each month?": {
            "url_hash": "eb30",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_edit_count_monthly", "monthly edit count per editing software", "edits"),
                add_table("created_by_top_100_edit_count_yearly", "yearly edit count per editing software", "Editing Software", "created_by_top_100_edit_count_total", "created_by_name_to_link"),
            ]
        },
        "What's the market share of edits per month?": {
            "url_hash": "a008",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_edit_count_monthly_percent", "percent of edits that use each editing software per month", "%", percent=true, on_top_of_each_other=true),
            ]
        },
        "What's the total amount of contributors, edits and changesets of editing software over time?": {
            "url_hash": "6320",
            "content_functions": [
                add_multi_line_plot("created_by_top_10_new_contributor_count_monthly_accumulated", "total contributor count of editing software", "contributors"),
                add_multi_line_plot("created_by_top_10_edit_count_monthly_accumulated", "total edit count of editing software", "edits"),
                add_multi_line_plot("created_by_top_10_changeset_count_monthly_accumulated", "total changeset count of editing software", "changesets"),
            ]
        },
        "What kind of devices are used for mapping?": {
            "url_hash": "8ba9",
            "content_functions": [
                add_multi_line_plot("created_by_device_type_contributor_count_monthly", "monthly contributor count per device", "contributors"),
                add_multi_line_plot("created_by_device_type_edit_count_monthly", "monthly edit count per device", "edits"),
                add_multi_line_plot("created_by_device_type_edit_count_monthly_percent", "market share of edit per device", "%", percent=true, on_top_of_each_other=true),
            ]
        }
    },
    "Corporations": {
        "How many edits are added from corporations each month?":{
            "url_hash": "7034",
            "content_functions": [
                add_single_line_plot("corporation_top_100_edit_count_monthly_sum_top_k_percent", "percent of edits from corporation per month", "%", percent=true),
            ]
        },
        "Which corporations are contributing how much?": {
            "url_hash": "b34d",
            "content_functions": [
                add_multi_line_plot("corporation_top_10_edit_count_monthly", "monthly edits per corporation", "edits"),
                add_table("corporation_top_100_edit_count_yearly", "monthly edits per corporation", "Corporation", "corporation_top_100_edit_count_total", "corporation_name_to_link"),
            ]
        },
        "What's the total amount of contributors, edits and changesets from corporations over time?": {
            "url_hash": "4ef4",
            "content_functions": [
                add_multi_line_plot("corporation_top_10_new_contributor_count_monthly_accumulated", "total contributor count of corporations", "contributors"),
                add_multi_line_plot("corporation_top_10_edit_count_monthly_accumulated", "total edit count of corporations", "edits"),
                add_multi_line_plot("corporation_top_10_changeset_count_monthly_accumulated", "total changeset count of corporations", "changesets"),
            ]
        },
        "Where are the top 10 corporations contributing?": {
            "url_hash": "e19b",
            "content_functions": [
                add_multiple_map_plots("corporation_top_10_edit_count_maps_total")
            ]
        },
    },
    "Source":{
        "How often is the 'source' tag used?": {
            "url_hash": "9267",
            "content_functions": [
                add_single_line_plot("source_edit_count_monthly_percent", "monthly percent of edits that use at least one source tag", "%", percent=true),
            ]
        },
        "How many contributors use which source each month?": {
            "url_hash": "6c08",
            "content_functions": [
                add_multi_line_plot("source_top_10_contributor_count_monthly", "monthly contributor count per source", "contributors"),
                add_table("source_top_100_contributor_count_yearly", "yearly contributor count per source", "Corporation", "source_top_100_contributor_count_total", "imagery_and_source_name_to_link"),
            ]
        },
        "How many edits does each source have per month?": {
            "url_hash": "daf4",
            "content_functions": [
                add_multi_line_plot("source_top_10_edit_count_monthly", "monthly edit count per source", "edits"),
                add_table("source_top_100_edit_count_yearly", "yearly edit count per source", "Source", "source_top_100_edit_count_total", "imagery_and_source_name_to_link"),
            ]
        },
        "What's the total amount of contributors, edits and changesets of sources over time?": {
            "url_hash": "7e84",
            "content_functions": [
                add_multi_line_plot("source_top_10_new_contributor_count_monthly_accumulated", "total contributor count of sources", "contributors"),
                add_multi_line_plot("source_top_10_edit_count_monthly_accumulated", "total edit count of sources", "edits"),
                add_multi_line_plot("source_top_10_changeset_count_monthly_accumulated", "total changeset count of sources", "changesets"),
            ]
        }
    },
    "Imagery Service":{
        "How popular are imagery services?": {
            "url_hash": "4f2c",
            "content_functions": [
                add_single_line_plot("imagery_edit_count_monthly_percent", "monthly percent of edits that use at least one imagery tag", "%", percent=true),
                add_text(
                    "This graph is based on imagery tag set automatically by iD, Vespucci and Go Map!!. As other editors are" +
                    " not using it and iD is vastly more popular than other relevant editors this graph is very close to" +
                    " 'market share of iD by edit volume'. JOSM users are typically using source field to note actually" +
                    " used sources."
                ),
            ]
        },
        "How many contributors does each imagery service have per month?": {
            "url_hash": "5bc5",
            "content_functions": [
                add_multi_line_plot("imagery_top_10_contributor_count_monthly", "monthly contributor count per imagery software", "contributors"),
                add_table("imagery_top_100_contributor_count_yearly", "yearly contributor count per imagery software", "Imagery Software", "imagery_top_100_contributor_count_total", "imagery_and_source_name_to_link"),
            ]
        },
        "How many edits does each imagery service have per month?": {
            "url_hash": "af79",
            "content_functions": [
                add_multi_line_plot("imagery_top_10_edit_count_monthly", "monthly edit count per imagery service", "edits"),
                add_table("imagery_top_100_edit_count_yearly", "yearly edit count per imagery software", "Imagery Software", "imagery_top_100_edit_count_total", "imagery_and_source_name_to_link"),
            ]
        },
        "What's the total amount of contributors, edits and changesets of imagery services over time?": {
            "url_hash": "327d",
            "content_functions": [
                add_multi_line_plot("imagery_top_10_new_contributor_count_monthly_accumulated", "total contributor count of imagery services", "contributors"),
                add_multi_line_plot("imagery_top_10_edit_count_monthly_accumulated", "total edit count of imagery services", "edits"),
                add_multi_line_plot("imagery_top_10_changeset_count_monthly_accumulated", "total changeset count of imagery services", "changesets"),
            ]
        }
    },
    "Hashtags":{
        "How popular are hashtags?": {
            "url_hash": "2e20",
            "content_functions": [
                add_single_line_plot("hashtag_edit_count_monthly_percent", "percent of monthly edits that use at least one hashtag", "%", percent=true),
                add_single_line_plot("hashtag_contributor_count_monthly_percent", "percent of monthly contributors that use at least one hashtag", "%", percent=true),
            ]
        },
        "How many contributors does each hashtag have per month?": {
            "url_hash": "bd85",
            "content_functions": [
                add_multi_line_plot("hashtag_top_10_contributor_count_monthly", "monthly contributor count per hashtag", "contributors"),
                add_table("hashtag_top_100_contributor_count_yearly", "yearly contributor count per hashtag", "Hashtag", "hashtag_top_100_contributor_count_total"),
            ]
        },
        "How many edits does each hashtag have per month?": {
            "url_hash": "f0e6",
            "content_functions": [
                add_multi_line_plot("hashtag_top_10_edit_count_monthly", "monthly edit count per hashtag", "edits"),
                add_table("hashtag_top_100_edit_count_yearly", "yearly edit count per hashtag", "Hashtag", "hashtag_top_100_edit_count_total"),
            ]
        },
        "What's the total amount of contributors, edits and changesets of hashtags over time?": {
            "url_hash": "4b4a",
            "content_functions": [
                add_multi_line_plot("hashtag_top_10_new_contributor_count_monthly_accumulated", "total contributor count of hashtags", "contributors"),
                add_multi_line_plot("hashtag_top_10_edit_count_monthly_accumulated", "total edit count of hashtags", "edits"),
                add_multi_line_plot("hashtag_top_10_changeset_count_monthly_accumulated", "total changeset count of hashtags", "changesets"),
            ]
        },
        "Where are the top 10 hashtags used?": {
            "url_hash": "bea0",
            "content_functions": [
                add_multiple_map_plots("hashtag_top_10_edit_count_maps_total")
            ]
        },
    },
    "StreetComplete":{
        "How popular is StreetComplete in the OSM community?": {
            "url_hash": "465b",
            "content_functions": [
                add_text(
                    "<a href='https://streetcomplete.app/'>StreetComplete</a> is an Android app where editing is done by" +
                    " answering predefined questions called 'quests'. This editor is much simpler to use than alternatives" +
                    ", but does not allow freeform editing. For example, adding missing opening hours is really easy, but" +
                    " you cannot map a missing road."
                ),
                add_single_line_plot("streetcomplete_contributor_count_monthly_percent", "percent of contributors that use streetcomplete per month", "%", percent=true),
                add_single_line_plot("streetcomplete_contributor_count_monthly", "contributors that use streetcomplete per month", "contributors"),
                add_single_line_plot("streetcomplete_edit_count_monthly_percent", "percent of edits made with streetcomplete per month", "%", percent=true),
                add_single_line_plot("streetcomplete_edit_count_monthly", "edits made with streetcomplete per month", "edits"),
            ]
        },
        "How many edits does each quest have?": {
            "url_hash": "6773",
            "content_functions": [
                add_table("streetcomplete_top_300_edit_count_yearly", "yearly edit count per quest", "StreetComplete Quest", "streetcomplete_top_300_edit_count_total"),
            ]
        },
        "What's the total amount of contributors and edits of the top quests over time?": {
            "url_hash": "d06d",
            "content_functions": [
                add_multi_line_plot("streetcomplete_top_10_new_contributor_count_monthly_accumulated", "total contributor count of quests", "contributors"),
                add_multi_line_plot("streetcomplete_top_10_edit_count_monthly_accumulated", "total edit count of quests", "edits"),
                add_multi_line_plot("streetcomplete_top_10_changeset_count_monthly_accumulated", "total changeset count of quests", "changesets"),
            ]
        },
        "Where is StreetComplete used the most?": {
            "url_hash": "52ed",
            "content_functions": [
                add_map_plot("streetcomplete_edit_count_map_total", "total edits")
            ]
        },
    },
    "Bot": {
        "How often are edits created with the help of bots?": {
            "url_hash": "785b",
            "content_functions": [
                add_single_line_plot("bot_edit_count_monthly_percent", "percent of edits created with a bot per month", "%", percent=true),
                add_single_line_plot("bot_edit_count_monthly", "edits created with a bot per month", "edits"),
            ]
        },
        "What's the total amount of contributors, edits and changesets that use bots over time?": {
            "url_hash": "0725",
            "content_functions": [
                add_single_line_plot("bot_new_contributor_count_monthly_accumulated", "total contributor count that used a bot", "contributors"),
                add_single_line_plot("bot_edit_count_monthly_accumulated", "total edit count that used a bot", "edits"),
                add_single_line_plot("bot_changeset_count_monthly_accumulated", "total changeset count that used a bot", "changesets"),
            ]
        },
        "How many distinct users use bots per month?": {
            "url_hash": "da7d",
            "content_functions": [
                add_single_line_plot("bot_contributor_count_monthly", "contributors using bots per month", "contributors"),
            ]
        },
        "Where are bots used?": {
            "url_hash": "ed95",
            "content_functions": [
                add_map_plot("bot_edit_count_map_total", "total edits")
            ]
        },
        "What's the average edit count per changeset over time?": {
            "url_hash": "ae72",
            "content_functions": [
                add_single_line_plot("bot_avg_edit_count_per_changeset_monthly", "average number of edits per changeset per month using bots", "average number of edits per changeset")
            ]
        },
        "What are the most used bot tools?": {
            "url_hash": "e985",
            "content_functions": [
                add_table("bot_created_by_top_100_edit_count_yearly", "yearly edit count per bot", "Bot", "bot_created_by_top_100_edit_count_total", "created_by_name_to_link")
            ]
        }
    },
    "Tags": {
        "What are the most popular tags for changesets?": {
            "url_hash": "b370",
            "content_functions": [
                add_multi_line_plot("all_tags_top_10_changeset_count_monthly_percent", "percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("all_tags_top_10_changeset_count_monthly", "occurance of tag in changesets per month", "changesets"),
                add_table("all_tags_top_100_changeset_count_yearly", "yearly occurance of tag in changesets", "Tag", "all_tags_top_100_changeset_count_total")
            ]
        },
        "What are the most popular tags for changesets per selected editing software?": {
            "url_hash": "2fb7",
            "content_functions": [
                add_text(
                    "In general the changeset tags are set by the editing software. Thats why its interesting to look at" +
                    " the tag usage per editing software.",
                ),
                // TODO: maybe save them all in one .json. This would be a cleaner I think.
                add_multi_line_plot("created_by_JOSM_all_tags_top_10_changeset_count_monthly_percent", "JOSM: percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("created_by_iD_all_tags_top_10_changeset_count_monthly_percent", "iD: percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("created_by_Potlatch_all_tags_top_10_changeset_count_monthly_percent", "Potlatch: percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("created_by_StreetComplete_all_tags_top_10_changeset_count_monthly_percent", "StreetComplete: percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("created_by_RapiD_all_tags_top_10_changeset_count_monthly_percent", "RapiD: percent of occurance of tag in changesets per month", "%", percent=true),
                add_multi_line_plot("created_by_Vespucci_all_tags_top_10_changeset_count_monthly_percent", "Vespucci: percent of occurance of tag in changesets per month", "%", percent=true),
            ]
        },
    },
}



selection_options = {}
url_hash_to_topic_question = {}
for (const [topic, topic_obj] of Object.entries(topics)) {
    selection_options[topic] = {}
    for (const [question, question_obj] of Object.entries(topic_obj)) {
        selection_options[topic][question] = {}
        url_hash_to_topic_question[question_obj["url_hash"]] = [topic, question]
    }
}

window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }

function options_to_selection(select, keys){
    prev_value = select.value
    while (select.firstChild) {
        select.removeChild(select.lastChild)
    }
    for (key of keys){
        var opt = document.createElement('option')
        opt.value = key
        opt.innerHTML = key.replaceAll("_", " ")
        select.appendChild(opt)
    }
    if (keys.includes(prev_value)){
        select.value = prev_value
    }
}

data_cache = {}
data_cache_list = []
max_cache_size = 30
async function load_data(data_name){
    if (data_name in data_cache){
        return data_cache[data_name]
    } else {
        data_cache[data_name] = await fetch("assets/data/" + data_name + ".json").then(response => {return response.json()})
        data_cache_list.push(data_name)
        if (data_cache_list.length > max_cache_size){
            delete data_cache[data_cache_list.shift()]
        }
        return data_cache[data_name]
    }
    
}

function add_div(id, class_str, parent_div=null){
    let div = document.createElement('div')
    div.id = String(id)
    div.style.display = "inline-block"
    div.classList.add(class_str);
    if (parent_div == null){
        document.getElementById('data').appendChild(div)
    } else {
        parent_div.appendChild(div)
    }
    return div
}

function add_text(text){
    show_content = async function(div_id){
        div = add_div(div_id, "textDiv")
        div.insertAdjacentHTML('beforeend', text);
    }
    return {"show": show_content}
}

function get_plot_config(){
    return {"displayModeBar": false, "staticPlot":(screen.width < 850)}
}

function get_plot_layout(){
    return {
        "font": {"family": "Times", "size": "15"},
        "paper_bgcolor": "#dfdfdf",
        "plot_bgcolor": "#dfdfdf",
    }
}

function get_line_plot_layout(plot_title, unit, percent, bar_chart_on_top_of_each_other){
    layout = Object.assign({}, get_plot_layout(), {
        "margin": {"l": 55, "r": 55, "b": 55, "t": 55},
        "title": {"text": plot_title},
        "xaxis": {"title": {"text": "time"}},
        "yaxis": {"title": {"text": unit}, "rangemode": "tozero"},
    })
    if (percent){
        layout["yaxis"]["range"] = [0, 101]
    }
    if (bar_chart_on_top_of_each_other){
        layout["barmode"] = "stack"
    }
    return  layout
}

function get_map_plot_layout(plot_title, max_z_value){
    colorscale = [
        [0, "rgba(255,255,255,0)"],
        [0.00000001, "rgb(12,51,131)"],
        [1 / 1000, "rgb(10,136,186)"],
        [1 / 100, "rgb(242,211,56)"],
        [1 / 10, "rgb(242,143,56)"],
        [1, "rgb(217,30,30)"],
    ]
    layout = Object.assign({}, get_plot_layout(), {
        "margin": {"l": 20, "r": 20, "b": 35, "t": 35},
        "images": [{
            "source": "assets/background_map.png",
            "xref": "x",
            "yref": "y",
            "x": 0,
            "y": 180,
            "sizex": 360,
            "sizey": 180,
            "sizing": "stretch",
            "opacity": 1,
            "layer": "below",
        }],
        "xaxis": {"showgrid": false, "visible": false},
        "yaxis": {"showgrid": false, "visible": false, "scaleanchor": "x", "scaleratio": 1},
        "coloraxis": {"colorscale": colorscale, "cmin": 0, "cmax": max_z_value},
        "title": {"text": plot_title},
    })
    return layout
}

function add_single_line_plot(data_name, plot_title, unit, percent=false){
    show_content = async function(div_id){
        data = await load_data(data_name)
        div = add_div(div_id, "dataDiv")
        traces = [{"x": data["x"], "y": data["y"], "mode": "lines", "name": "", "hovertemplate": "%{x}<br>%{y:,} " + unit}]
        Plotly.newPlot(div, traces, get_line_plot_layout(plot_title, unit, percent), get_plot_config())
    }
    return {"show": show_content, "save_plot": async function(div_id){save_plot(data_name, div_id)}, "save_data": async function(){save_data(data_name)}}
}

function add_multi_line_plot(data_name, plot_title, unit, percent=false, on_top_of_each_other=false, bar_chart=false){
    show_content = async function(div_id){
        data = await load_data(data_name)
        div = add_div(div_id, "dataDiv")
        traces = []
        for (i in data["y_names"]){
            trace = {
                "x": data["x"],
                "y": data["y_list"][i],
                "mode": "lines",
                "name": data["y_names"][i],
                "hovertemplate": "%{x}<br>%{y:,} " + unit
            }
            if (on_top_of_each_other){
                trace["stackgroup"] = "one"
            }
            if (bar_chart){
                trace["type"] = "bar"
            }
            traces.push(trace)
        }
        
        bar_chart_on_top_of_each_other = bar_chart && on_top_of_each_other
        Plotly.newPlot(div, traces, get_line_plot_layout(plot_title, unit, percent, bar_chart_on_top_of_each_other), get_plot_config())
    }
    return {"show": show_content, "save_plot": async function(div_id){save_plot(data_name, div_id)}, "save_data": async function(){save_data(data_name)}}
}

function get_map_plot_traces(x, y, z, max_z_value){
    traces = [{
            "type": "histogram2d",
            "x": x,
            "y": y,
            "z": z,
            "zmax": max_z_value,
            "histfunc": "sum",
            "autobinx": false,
            "xbins": {"start": 0, "end": 360, "size": 1},
            "autobiny": false,
            "ybins": {"start": 0, "end": 180, "size": 1},
            "coloraxis": "coloraxis",
    }]
    return traces
}

function add_map_plot(data_name, plot_title){
    show_content = async function(div_id){
        data = await load_data(data_name)
        div = add_div(div_id, "dataDiv")
        traces = get_map_plot_traces(data[data_name]["x"], data[data_name]["y"], data[data_name]["z"], data["max_z_value"])
        Plotly.newPlot(div, traces, get_map_plot_layout(plot_title, data["max_z_value"]), get_plot_config())
    }
    return {"show": show_content, "save_plot": async function(div_id){save_plot(data_name, div_id)}, "save_data": async function(){save_data(data_name)}}
}

function add_multiple_map_plots(data_name){
    show_content = async function(div_id){
        data = await load_data(data_name)
        for (const map_name of Object.keys(data[data_name])) {
            div = add_div(map_name, "dataDiv")
            traces = get_map_plot_traces(data[data_name][map_name]["x"], data[data_name][map_name]["y"], data[data_name][map_name]["z"], data["max_z_value"])
            Plotly.newPlot(div, traces, get_map_plot_layout(map_name, data["max_z_value"]), get_plot_config())
        }
    }
    save_map_plots = async function(div_id){
        data = await load_data(data_name)
        for (const map_name of Object.keys(data[data_name])){
            save_plot(data_name + "_" + map_name.replaceAll(" ", "_"), map_name)
        }
    }
    return {"show": show_content, "save_plot": save_map_plots, "save_data": async function(){save_data(data_name)}}
}

function add_table(data_name, title, y_names_category, data_name_total, data_name_name_to_link=undefined){
    show_content = async function(div_id){
        data = await load_data(data_name)
        data_total = await load_data(data_name_total)
        if (data_name_name_to_link !== undefined){
            name_to_link = await load_data(data_name_name_to_link)
        } else {
            name_to_link = {}
        }
        
        div = add_div(div_id, "dataDiv")
        div.style.width = "100%"
        div.style.aspectRatio = "auto"
        div.innerHTML = get_table_html(title, data, data_total, y_names_category, name_to_link)
    }
    return {"show": show_content, "save_data": async function(){save_data(data_name, data_name_total)}}
}

function get_table_html(title, data, data_total, y_names_category, name_to_link){
    let head_entries = ["Rank", y_names_category].concat(data["x"]).concat(["total"])
    let head = "<tr>"
    for (var i in head_entries){
        if (i == 0){
            head += "<th>" + head_entries[i] + "</th>"
        } else {
            head += "<th class=\"sorting\" onclick=\"sort_table(event)\">" + head_entries[i] + "</th>"
        }
    }
    head += "</tr>"
    let body = ""
    for (row_index in data["y_names"]){
        let name = data["y_names"][row_index]
        if (name in name_to_link){
            name = "<a href=" + name_to_link[name] + ">" + name + "</a>"
        }
        body += "<tr><td>" + String(parseInt(row_index) + 1) + "</td><td>" + name + "</td>"
        for (y_value of data["y_list"][row_index]){
            body += "<td>" + y_value.toLocaleString("en-US") + "</td>"
        }
        body += "<td>" + data_total["y_list"][row_index].toLocaleString("en-US") + "</td></tr>"
    }
    return "<h3>" + title + "</h3><table style='margin: 0 auto;'>" + head + body + "</table>"
}


function download(data_str, title, file_ending){
    const downloadLink = document.createElement('a');
    downloadLink.download = title + "." + file_ending;
    if (file_ending == "csv"){
        data_str = window.URL.createObjectURL(new Blob([data_str], { type: 'text/csv' }))
    } else if (file_ending == "json"){
        data_str = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data_str))
    }
    downloadLink.href = data_str
    downloadLink.style.display = 'none';
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
}

async function save_plot(data_name, div_id){
    await Plotly.toImage(document.getElementById(div_id), {format:'png',height:500,width:1000}).then(function(png_str){
        download(png_str, data_name, "png")
    })
}


async function save_data(data_name, data_name_2=null){
    data = await load_data(data_name)
    download(data, data_name, "json")
    if (data_name_2 !== null){
        data_2 = await load_data(data_name_2)
        download(data_2, data_name_2, "json")
    }
}


function init(){
    update_select_0()
    if(window.location.hash) {
        url_hash = window.location.hash.substring(1)
        if (url_hash in url_hash_to_topic_question){
            topic = url_hash_to_topic_question[url_hash][0]
            question = url_hash_to_topic_question[url_hash][1]
            if (topic in selection_options && question in selection_options[topic]){
                document.getElementById('select_0').value = topic
                update_select_1()
                document.getElementById('select_1').value = question
            }
        }
    }
    update_content(true)
    window.addEventListener('resize', function(event) {update_content(false)}, true);
}

function update_select_0(){
    options_to_selection(document.getElementById('select_0'), Object.keys(selection_options))
    update_select_1()
}

function update_select_1(){
    current_select_0 = document.getElementById('select_0').value
    options_to_selection(document.getElementById('select_1'), Object.keys(selection_options[current_select_0]))
}

function on_change_select_0(){
    update_select_1()
    update_content(true)
}

function on_change_select_1(){
    update_content(true)
}

function get_current_select(){
    return [document.getElementById('select_0').value, document.getElementById('select_1').value]
}

async function update_content(log_update){
    document.getElementById("data").innerHTML = ""  
    topic_question = get_current_select()
    topic = topic_question[0]
    question = topic_question[1]
    console.log(topic, question)
    if (log_update){
        plausible("Selected Plot(s)", {props: {"Topic Question": topic + ": " + question}})
    }

    for (const [index, content_functions] of topics[topic][question]["content_functions"].entries()){
        await content_functions["show"](index)
    }

    document.getElementById('save_plot_btn').onclick = async function(){
        for (const [index, content_functions] of topics[topic][question]["content_functions"].entries()){
            if ("save_plot" in content_functions){
                content_functions["save_plot"](index)
            }
        }
        plausible("Download Plot(s)", {props: {"Topic Question": topic + ": " + question}})
    }
    document.getElementById('save_data_btn').onclick = async function(){
        for (const [index, content_functions] of topics[topic][question]["content_functions"].entries()){
            if ("save_data" in content_functions){
                content_functions["save_data"](index)
            }
        }
        plausible("Download Data", {props: {"Topic Question": topic + ": " + question}})
    }
    history.replaceState(null, "", "#" + topics[topic][question]["url_hash"])
}

async function sort_table(e){
    for (var child=e.srcElement.parentElement.firstChild.nextSibling; child!==null; child=child.nextSibling) {
        if (child != e.srcElement && !child.classList.contains('sorting')){
            child.classList.remove('sorting_asc', 'sorting_desc');
            child.classList.add('sorting');
        }
    }

    if (e.srcElement.classList.contains('sorting')){
        e.srcElement.classList.remove('sorting');
        e.srcElement.classList.add('sorting_desc');
        var th = e.srcElement
        var ascending = false
    } else if (e.srcElement.classList.contains('sorting_desc')){
        e.srcElement.classList.remove('sorting_desc');
        e.srcElement.classList.add('sorting_asc');
        var th = e.srcElement
        var ascending = true
    } else {
        e.srcElement.classList.remove('sorting_asc');
        e.srcElement.classList.add('sorting');
        var th = e.srcElement.parentElement.firstChild
        var ascending = true
    }
    
    const getCellValue = (tr, idx) => tr.children[idx].innerText.replaceAll(",", "") || tr.children[idx].textContent.replaceAll(",", "");

    const comparer = (idx, asc) => (a, b) => ((v1, v2) => 
        v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2) ? v1 - v2 : v1.toString().localeCompare(v2)
        )(getCellValue(asc ? a : b, idx), getCellValue(asc ? b : a, idx));

    const table = th.closest('table');
    Array.from(table.querySelectorAll('tr:nth-child(n+2)'))
        .sort(comparer(Array.from(th.parentNode.children).indexOf(th), ascending))
        .forEach(tr => table.appendChild(tr));
    
    for (var i in table.rows){
        if (i > 0){
            table.rows[i].cells[0].innerText = String(i)
        }
    }
}

</script>


<body onload="init()">
<h2>OpenStreetMap Statistics</h2>
<div class="textDiv" style="padding-top: 0;">
The <a href="https://github.com/piebro/openstreetmap-statistics">code</a> for creating the plots is open source. There is also some documentation describing the <a href="https://github.com/piebro/openstreetmap-statistics#methodology">methodology</a> and what to consider when interpreting the data. Check out this <a href="https://piebro.github.io/openstreetmap-statistics/jupyter_lite/retro/notebooks/?path=custom_plots_browser.ipynb">notebook</a> to create your own custom plots in a browser.
</div>
<div>
    <select onchange="on_change_select_0()" id="select_0"></select>
    <select onchange="on_change_select_1()" id="select_1"></select>
</div>
<div id="data"></div>
<div>
    <button id="save_plot_btn">save plot(s)</button>
    <button id="save_data_btn">save data</button>
</div>
</br>
</body>
</html>
